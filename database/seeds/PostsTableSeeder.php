<?php

use App\Models\Post;
use Illuminate\Database\Seeder;

class PostsTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        Post::truncate();

        Post::create([
            'title'     => 'Обзор HTTP протокола',
            'body'    => 'HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP  лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser). Полученный итоговый документ будет (может) состоять из различных поддокументов являющихся частью итогового документа: например, из отдельно полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.',
            'user_id' => 2,
            'category_id' => 2,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Описание Стандартов ES',
            'body'    => 'ES — это просто сокращение для ECMAScript. Каждое издание ECMAScript получает аббревиатуру ES с последующим его номером. Всего существует 8 версий ECMAScript. ES1 была выпущена в июне 1997 года, ES2 — в июне 1998 года, ES3 — в декабре 1999 года, а версия ES4 — так и не была принята. Не будем углубляться в эти версии, так как они морально устарели, а рассмотрим только последние четыре.


ES5 был выпущен в декабре 2009 года, спустя 10 лет после выхода третьего издания. Среди изменений можно отметить:

поддержку строгого режима (strict mode);
аксессоры getters и setters;
возможность использовать зарезервированные слова в качестве ключей свойств и ставить запятые в конце массива;
многострочные строковые литералы;
новую функциональность в стандартной библиотеке;
поддержку JSON.
Версия ES6/ES2015 вышла в июне 2015 года. Это также принесло некую путаницу в связи с названием пакета, ведь ES6 и ES2015 — это одно и то же. С выходом этого пакета обновлений комитет принял решение перейти к ежегодным обновлениям. Поэтому издание было переименовано в ES2015, чтобы отражать год релиза. Последующие версии также называются в соответствии с годом их выпуска. В этом обновлении были сделаны следующие изменения:
обавлено деструктурирующее присваивание;
добавлены стрелочные функции;
в шаблонных строках можно объявлять строки с помощью ` (обратных кавычек). Шаблонные строки могут быть многострочными, также могут интерполироваться;
let и const — альтернативы var для объявления переменных. Добавлена «временная мертвая зона»;
итератор и протокол итерации теперь определяют способ перебора любого объекта, а не только массивов. Symbol используется для присвоения итератора к любому объекту;
добавлены функции-генераторы. Они используют yield для создания последовательности элементов. Функции-генераторы могут использовать yield* для делегирования в другую функцию генератора, кроме этого они могут возвращать объект генератора, который реализует оба протокола;
добавлены промисы.
ES2016 (ES7) вышла в июне 2016 года. Среди изменений в этой версии ECMAScript можно отметить:

оператор возведения в степень **;
метод Array.prototype.includes, который проверяет, содержится ли переданный аргумент в массиве.
Спустя еще год выходит версия ES2017 (ES8). Данный стандарт получил следующие изменения:

асинхронность теперь официально поддерживается (async/await);
«висячие» запятые в параметрах функций. Добавлена возможность ставить запятые в конце списка аргументов функций;
добавлено два новых метода для работы со строками: padStart() и padEnd(). Метод padStart() подставляет дополнительные символы слева, перед началом строки. А padEnd(), в свою очередь, справа, после конца строки;
добавлена функция Object.getOwnPropertyDescriptors(), которая возвращает массив с дескрипторами всех собственных свойств объекта;
добавлено разделение памяти и объект Atomics.
Что же касается ES.Next, то этот термин является динамическим и автоматически ссылается на новую версию ECMAScript. Стоит отметить, что каждая новая версия приносит новые функции для языка.',
            'user_id' => 2,
            'category_id' => 2,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Генераторы в JS',
            'body'    => 'Генераторы – новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.
Для объявления генератора используется новая синтаксическая конструкция: function* (функция со звёздочкой).

Её называют «функция-генератор» (generator function).
При создании генератора код находится в начале своего выполнения.

Основным методом генератора является next(). При вызове он возобновляет выполнение кода до ближайшего ключевого слова yield. По достижении yield выполнение приостанавливается, а значение – возвращается во внешний код:',
            'user_id' => 2,
            'category_id' => 2,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Семантическая верстка',
            'body'    => 'Семантическая верстка — это изучение значений слов и выражений. В html ничто иное как написание элементов со смыслом. Семантический элемент четко описывает свое значение как для браузеров, так и для разработчиков.

Давайте взглянем на отличие семантического элемента от обычного.

Например div или span — простые элементы, глядя на них мы не можем понять какого типа контент в них содержится. Это может быть просто текст, картинка, или другие теги.

Теперь семантические form, table, и article здесь уже совсем другое дело. Только прочитав названия мы можем с легкостью понять что внутри этих тегов. Пример верстки обычной и семантической:',
            'user_id' => 2,
            'category_id' => 2,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Векторная графика',
            'body'    => '(Scalable Vector Graphics — SVG) является языком разметки расширенным из XML для описания двухмерной векторной графики. SVG по существу является графикой, так же, как XHTML — текстом.

SVG по своим возможностям приближается к запатентованной технологии Adobe Flash, но отличается от неё тем, что SVG является рекомендацией W3C (то есть, стандартом), и тем, что это формат, основанный на XML, в противовес закрытому двоичному формату Flash. Он явно спроектирован для работы с другими стандартами W3C, такими, как CSS, DOM и SMIL. 

SVG-графика и связанные с ней поведения определяются в текстовых XML-файлах, что означает, что их можно искать, индексировать, создавать сценарии и сжимать. Кроме того, это означает, что они могут быть созданы и отредактированы с помощью любого текстового редактора и программ для рисования. 

SVG — открытый стандарт, разработанный  World Wide Web консорциумом (W3C) с 1999 года.',
            'user_id' => 2,
            'category_id' => 2,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Кросс браузерная верстка',
            'body'    => 'Хочу поделиться своей небольшой библиотекой. Интересно услышать ваше мнение о ней.

Сразу к сути дела: htmlmake — это js-функция, позволяющая создавать строку с html-разметкой внутри для дальнейшей вставки в DOM-дерево.

Зачем это использовать?

Начну немного издалека. Современную веб-разработку я бы условно поделил на 2 категории:
Сайты, в которых html генерируется сервером, а javascript используется в основном для анимаций и ajax запросов (далее их я так и буду называть «сайты»);
Одностраничные приложения, в которых js берет на себя всю отрисовку DOM (далее «веб-приложения»).

Если говорить о веб-приложениях, то в них логично распространение js-шаблонизаторов для генерации html (например Jade). Моя библиотека рассчитана на 1 группу, в которой чаще всего распространен компонентный подход к написанию js-ов. Когда внедрять js-шаблонизатор ради генерации несложного набора html элементов слишком дорого, обычно html генерируется своим jquery кодом. Допустим, нам необходимо собрать следующий html:',
            'user_id' => 2,
            'category_id' => 1,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'React hooks',
            'body'    => 'В этом примере, useState — это хук (определение хука дано ниже). Мы вызываем его, чтобы наделить наш функциональный компонент внутренним состоянием. React будет хранить это состояние между рендерами. Вызов useState возвращает две вещи: текущее значение состояния и функцию для его обновления. Эту функцию можно использовать где угодно, например, в обработчике событий. Она схожа с this.setState в классах, но не сливает новое и старое состояние вместе. Сравнение хука useState и this.state приводится на странице Использование хука состояния.

Единственный аргумент useState — это начальное состояние. В примере выше — это 0, так как наш счётчик начинается с нуля. Заметьте, что в отличие от this.state, в нашем случае состояние может, но не обязано, быть объектом. Исходное значение аргумента используется только при первом рендере.

Синтаксис деструктуризации массивов позволяет нам по разному называть переменные состояния, которые мы объявляем при вызове useState. Так как имён этих переменных нет в API useState, React предполагает, что если вы вызываете useState много раз, вы делаете это в одинаковой последовательности при каждом рендере. Мы расскажем, почему это работает и когда это целесообразно, немного позже.

Что же такое хук?
Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов. (Мы не рекомендуем сразу же переписывать существующие компоненты, но при желании, вы можете начать использовать хуки в своих новых компонентах.)

React содержит несколько встроенных хуков, таких как useState. Вы также можете создавать собственные хуки, чтобы повторно использовать их в других своих компонентах. Давайте для начала рассмотрим встроенные хуки.
Вам скорее всего доводилось ранее запрашивать данные, делать подписки или вручную менять DOM из React-компонента. Мы расцениваем эти операции как «побочные эффекты» (или сокращённо «эффекты»), так как они могут влиять на работу других компонентов и их нельзя выполнить во время рендера.

С помощью хука эффекта useEffect вы можете выполнять побочные эффекты из функционального компонента. Он выполняет ту же роль, что и componentDidMount, componentDidUpdate и componentWillUnmount в React-классах, объединив их в единый API. Вы можете найти сравнение useEffect и этих методов на странице использование хука эффекта.

К примеру, этот компонент устанавливает заголовок документа после того, как React обновляет DOM:
',
            'user_id' => 2,
            'category_id' => 1,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Html-maker — удобная и простая генерация html с помощью coffeescript',
            'body'    => 'Кроссбраузерность — это одинаковое отображение и работа сайта в различных браузерах. Если не задуматься над этим вопросом на этапе верстки, то, создав сайт, вы увидите, что в разных браузерах он отображается по-разному и не везде корректно.

Откуда возникла такая проблема? Дело в том, что браузеры используют разные движки. Браузерный движок занимается загрузкой, обработкой, отображением и расчетами данных. И хоть сегодня существует большое количество различных браузеров, если мы их разложим по используемым движкам, то увидим, что этих движков не так и много, так как создание своего движка является очень трудоемкой задачей.',
            'user_id' => 2,
            'category_id' => 2,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Junior, Middle, Senior — в чем разница и куда дальше?',
            'body'    => 'Привет всем! Меня зовут Александр Демура, в IT я работаю с 2004 года, сейчас руковожу центром разработки DataArt в Одессе (сам я из Питера, но это — отдельная история). В мои непосредственные обязанности входят найм и развитие наших специалистов, поэтому рассуждения на тему «синьёрности» сотрудников и качествах, необходимых для той или иной роли, для меня актуальны и привычны. Позволю себе традиционный дисклеймер — в этой статье изложен мой персональный взгляд (к счастью, в DataArt так можно — необязательно всем ходить строем по линейке). Написанный мной текст не претендует на истину в последней инстанции и вряд ли станет откровением для людей, уже разбирающихся в вопросе. Зато он будет полезен тем, кто только начинает путь в IT или не очень понимает, как и куда развиваться дальше, чувствует себя недооцененным или просто хочет расширить кругозор.

Изначально в DataArt не было формальной градации по уровню квалификации — мы ведь берем в команду человека целиком, со всеми плюсами и минусами, а не просто покупаем на рынке труда требуемую функцию. Если вдуматься, «джуниор», «мидл» или «синьор» — всего лишь штампы. Но такие ярлыки приходится использовать для упрощения картины мира и повышения эффективности коммуникации — они привычны и клиентам, и коллегам.

Это позволяет договориться о наборе ожиданий, предъявляемых к той или иной роли. Но живые люди редко идеально вписываются в удобные рамки, а производительность каждого специалиста в проекте зависит от множества параметров. Поэтому придумать объективную абстрактную метрику крутизны в вакууме практически невозможно.

Например, человек может блестяще проявить себя в одном проекте и вдруг сдуться в другом — чего ожидать от него в третьем? Кто-то может гениально отвечать на сложнейшие технические вопросы, но при этом порождать неподдерживаемый код. Кто-то наоборот — теряется на джуновых вопросах, имея за плечами десяток успешно сданных проектов. Вникать в подобные нюансы, помогать людям использовать свои сильные стороны и компенсировать слабости — одна из задач менеджмента. Общего решения она вроде бы до сих пор не имеет, что делает работу менеджера интересной, хотя подчас непростой.

ИНТЕРН
В DataArt есть практикантская программа, куда мы берем людей даже без опыта работы. У них есть три месяца, чтобы под руководством опытного ментора дорасти до уровня «джуниор». Для позиции интерна есть два основных требования:

Хороший английский.
Понимание выбранного инструмента и умение им пользоваться.
Требование к знанию английского у нас, на самом деле, общее для всех. DataArt — международная организация, большинство наших заказчиков находятся в США и Западной Европе, и даже внутренние коммуникации уже все больше на английском. Если человек — грамотный технический специалист, мы поможем ему разговориться и подтянуть язык — для этого есть корпоративные курсы и куча дополнительных инициатив. Но если человек без технического опыта (а интерн — как раз такой) еще и слабо знает английский, ему нужно обладать уникальными качествами, которые перекроют оба этих недостатка.

Про инструмент мысль тоже, мне кажется, простая. Если вы приходите на роль программиста, инструмент для вас — язык программирования со средствами разработки, которыми нужно уметь пользоваться. Если потенциальный интерн хочет разрабатывать на .NET, но не может объяснить, что делает CLR, чем «Equals» отличается от «==» или реализовать простейший алгоритм — шансов у него нет никаких. Приходить с нулевыми знаниями и надеяться, что всему научат на месте, параллельно выплачивая зарплату, бесполезно — слишком большой конкурс. За плечами многих кандидатов профессиональные курсы, они с легкостью отвечают на все теоретические вопросы и даже имеют опыт программирования «для себя». Конечно, таких людей берут в первую очередь.',
            'user_id' => 2,
            'category_id' => 3,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'описание Scala',
            'body'    => 'Язык Scala объединяет три вещи: статическую типизацию, объектно-ориентированный и функциональный подход. Как уже говорилось, Scala работает на виртуальной машине Java. Совместимость («свободное смешивание») этого языка с Java дает возможность писать на Scala Android-приложения. Кроме того, возможность компиляции в JavaScript позволяет разрабатывать веб-приложения на Scala.

Несмотря на некоторую схожесть и даже родственную связь этого языка с Java, целых 10 лет после появления Scala его «старший брат» хранил верность объектно-ориентированной парадигме. И только в 2014 году в Java 8 были включены элементы функционального подхода – лямбда-выражения.

Помимо упомянутых выше Java и C#, на Scala оказали влияние другие языки и технологии. Способ выражения свойств во многом заимствован из Sather. Из Smalltalk перекочевала концепция унифицированной объектной модели. Beta поделился идеей о вложенности всего подряд, включая классы. Абстрактные типы в Scala напоминают абстрактные типы сигнатур в SML и OCaml, обобщенные в контексте полноценных компонентов.

Кроме того, Scala перенял особенности таких функциональных языков, как Scheme, Standard ML и Haskell.
Я верю, что у Scala все-таки хорошие перпективы. Недаром многие крупные компании выбрали его. Несмотря на то, что путь, сочетающий ООП и ФП может показаться опасным и сбить с толку «пуритан», при аккуратном использовании, программирование на Scala может доставлять удовольствие.

Я не согласен с тем, что Scala в освоении труднее других языков программирования. Есть, конечно, определенный «барьер», связанный с необходимостью думать одновременно в разных парадигмах. Хотя на большинстве форумов этот язык почему-то обсуждают в контексте функционального программирования.

Мне приходилось слышать высказывания по типу: «Scala больше подходит для крупномасштабных систем, а не каких-то там Твиттеров». Но будет ошибкой полагать, что он создан только для этого. Я не думаю, что реализовать MVP (Minimum Viable Product) на Scala сложнее, чем на каком-то другом языке.

Я никогда не был особенно увлечен объектно-ориентированным программированием. С тех пор, как познакомился с Erlang, я к нему не возвращался. Затем я выбрал Scala для бэкэнд-разработки в новой компании и получил положительные отзывы. Это вселило в меня уверенность, что я сделал правильный выбор.',
            'user_id' => 2,
            'category_id' => 1,
            'is_published' => true
        ]);
        Post::create([
            'title'     => 'Изучаем WebAssembly',
            'body'    => 'Вы наверняка слышали, что WebAssembly очень быстрый. Но что это значит, и что это за технология в целом? Ответы на эти и другие вопросы в публикации.

Начать стоит с важного замечания. Заявления о высокой скорости и производительности WebAssembly (Wasm) или другой технологии не нужно воспринимать буквально. В них обычно идет речь об относительной скорости и производительности, то есть о скорости wasm по сравнению с чем-то. Держите это в уме.

WebAssembly — безопасный и эффективный низкоуровневый бинарный формат для веба. Давайте рассмотрим, что это значит.

Эффективность
Когда кто-то говорит о Wasm, как правило речь идёт о его потенциальной высокой производительности. Объясняют высокую производительность тем, что браузер компилирует Wasm в эффективный машинный код. Однако высокая производительность — не единственное объяснение эффективности WebAssembly.

Wasm изначально проектировался с учётом формата компактных бинарных файлов. Поэтому его можно быстро загружать. Но, что более важно, код Wasm может быть преобразован в машинный прямо во время загрузки. Это называется потоковой компиляцией.

До появления WebAssembly код, написанный на C++ или Rust, перед использованием в вебе приходилось компилировать в JavaScript. Современные виртуальные машины компилируют JavaScript в машинный код, но начать этот процесс, по сути, можно только тогда, когда весь JS-код будет загружен. WebAssembly, напротив, компилируется в машинный код по мере загрузки, что сильно влияет на скорость запуска кода на исполнение. Настолько сильно, что узким местом уже становится скорость загрузки данных по сети, особенно на мобильных устройствах.

Потоковая компиляция — это прекрасно. Но и здесь есть нюансы. Так что сама возможность компилирования кода в Wasm не всегда означает, что это непременно нужно делать. Не так уж и сложно написать такой JS-код, который будет компактнее по размеру, чем порция компилированного в Wasm кода на C++. Ведь коду на JS не нужно нести с собой машинерию для управления памятью или любые другие функции, предоставляемые самим браузером. То есть вам не придётся реализовывать Array или библиотеку для парсинга JSON. Эти возможности уже есть в среде исполнения JavaScript — в браузере.

Wasm, напротив, не имеет никакого особого представления о C++ (или любом другом языке). Поэтому среда исполнения Wasm не предоставляет стандартную библиотеку C++ и компилятору её приходится добавлять в каждый бинарный файл. Как минимум, должны быть включены используемые в коде части библиотеки.

Увы, такие подробности способны смутить иного читателя. Причина тому -- необходимость понимания того, как на самом деле работают и JS, и C++ и насколько они разные. Но не отчаивайтесь! Вы можете не понимать всех тонкостей, и тем не менее применять Wasm с пользой.

Безопасность
Развитие Web напрямую влияет на эволюцию браузеров. Браузеры постоянно наращивают свои возможности, всегда при этом оставаясь гарантами безопасности от злонамеренных действий со стороны. WebAssembly также следует по этому пути.

Wasm выполняется в песочнице, как и JavaScript. Он не имеет доступа к операционной системе, но имеет доступ к тем же API, что и JS. Поэтому WebAssembly не может выполнять произвольные системные вызовы или читать внутреннюю память браузера. Чтобы получить доступ к файловой системе, Wasm должен использовать File API, как JavaScript.

Это может показаться серьёзным ограничением, но безопасность — важный фундамент, на котором должна стоять любая технология.

WebAssembly обеспечивает дополнительную безопасность для таких языков, как C и C++. Классический пример — переполнение буфера, которое используется для внедрения вредоносного кода. Сами принципы работы WebAssembly делают невозможным появление этого класса уязвимостей. Вы можете переполнить буфер, C++ даёт такую возможность. Но внедрить вредоносный код не получится из-за отсутствия исполняемой памяти.

Однако, не стоит думать, что WebAssembly защищает от любых классов уязвимостей. Злоумышленник не сможет произвести атаку с инъекцией кода напрямую, однако у него остаётся возможность перехватить управление потоком исполнения через атаку повторного использования кода (code reuse attack) с помощью непрямых вызовов (indirect calls). Например, переполнение буфера способно вызвать перезапись указателя на функцию, да так, что указатель станет ссылаться на другую функцию. Упомянутые атаки против кода на C++ возможны благодаря самой природе языка. Использование языков вроде Rust позволяет избежать многих уязвимостей, но не всех. Да и для JavaScript существуют свои атаки подобного рода. Они есть и в других языках программирования, включая JavaScript.',
            'user_id' => 2,
            'category_id' => 3,
            'is_published' => true
        ]);
    }
}
